;;   Copyright (c) Rich Hickey. All rights reserved.
;;   Copyright (c) Aemon Cannon. All rights reserved.
;;   The use and distribution terms for this software are covered by the
;;   Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
;;   which can be found in the file CPL.TXT at the root of this distribution.
;;   By using this software in any fashion, you are agreeing to be bound by
;;   the terms of this license.
;;   You must not remove this notice, or any other, from this software.

(in-ns 'las3r)




(def
 #^{:arglists '([& items])
    :doc "Creates a new list containing the items."}
 list (. com.las3r.runtime.List creator))

(def
 #^{:arglists '([x seq])
    :doc "Returns a new seq where x is the first element and seq is
    the rest."}

 cons (fn* cons [x seq] (. com.las3r.runtime.RT (cons x seq))))

;;during bootstrap we don't have destructuring let, loop or fn, will redefine later
(def
 #^{:macro true}
 let (fn* let [& decl] (cons 'let* decl)))

(def
 #^{:macro true}
 loop (fn* loop [& decl] (cons 'loop* decl)))

(def
 #^{:macro true}
 fn (fn* fn [& decl] (cons 'fn* decl)))

(def
 #^{:arglists '([coll])
    :doc "Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil."}
 first (fn first [coll] (. com.las3r.runtime.RT (first coll))))

(def
 #^{:arglists '([coll])
    :doc "Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil."}  
 rest (fn rest [x] (. com.las3r.runtime.RT (rest x))))

(def
 #^{:doc "Same as (first (rest x))"
    :arglists '([x])}
 second (fn second [x] (first (rest x))))

(def
 #^{:doc "Same as (first (first x))"
    :arglists '([x])}
 ffirst (fn ffirst [x] (first (first x))))

(def
 #^{:doc "Same as (rest (first x))"
    :arglists '([x])}
 rfirst (fn rfirst [x] (rest (first x))))

(def
 #^{:doc "Same as (first (rest x))"
    :arglists '([x])}
 frest (fn frest [x] (first (rest x))))

(def
 #^{:doc "Same as (rest (rest x))"
    :arglists '([x])}
 rrest (fn rrest [x] (rest (rest x))))

(def
 #^{:arglists '([coll x])
    :doc "conj[oin]. Returns a new collection with the xs
    'added'. (conj nil item) returns (item).  The 'addition' may
    happen at different 'places' depending on the concrete type."}
 conj (fn conj [coll x] (. com.las3r.runtime.RT (conj coll x))))

(def
 #^{:arglists '([coll])
    :doc "Sequence. Returns a new ISeq on the collection. If the
    collection is empty, returns nil.  (seq nil) returns nil. seq also
    works on Strings and native arrays."
    :tag com.las3r.runtime.ISeq}
 seq (fn seq [coll] (. com.las3r.runtime.RT (seq coll))))

(def
 #^{:arglists '([c x])
    :doc "Evaluates x and tests if it is an instance of the class
    c. Returns true or false"}
 instance? (fn instance? [c x] (. com.las3r.runtime.RT (isInstance c x))))


(def
 #^{:arglists '([x])
    :doc "Return true if x implements ISeq"}
 seq? (fn seq? [x] (instance? com.las3r.runtime.ISeq x)))

(def
 #^{:arglists '([x])
    :doc "Return true if x is a String"}
 string? (fn string? [x] (instance? String x)))

(def
 #^{:arglists '([x])
    :doc "Return true if x implements IMap"}
 map? (fn map? [x] (instance? com.las3r.runtime.IMap x)))

(def
 #^{:arglists '([x])
    :doc "Return true if x implements IVector "}
 vector? (fn vector? [x] (instance? com.las3r.runtime.IVector x)))


(def
 #^{:arglists '([map key val])
    :doc "assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be <= (count vector)."}
 assoc
 (fn assoc [map key val] (. com.las3r.runtime.RT (assoc map key val))))


;;;;;;;;;;;;;;;;; metadata ;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def
 #^{:arglists '([obj])
    :doc "Returns the metadata of obj, returns nil if there is no metadata."}
 meta (fn meta [x]
        (if (instance? com.las3r.runtime.IObj x)
          (. #^com.las3r.runtime.IObj x meta))))

(def
 #^{:arglists '([#^com.las3r.runtime.IObj obj m])
    :doc "Returns an object of the same type and value as obj, with
    map m as its metadata."}
 with-meta (fn with-meta [#^com.las3r.runtime.IObj x m]
             (. x (withMeta m))))


(def 
 #^{:arglists '([coll])
    :doc "Return the last item in coll, in linear time"}
 last (fn last [s]
        (if (rest s)
          (recur (rest s))
          (first s))))

(def 
 #^{:arglists '([coll])
    :doc "Return a sequence of all but the last item in coll, in linear time"}
 butlast (fn butlast [s]
           (loop [ret [] s s]
             (if (rest s)
               (recur (conj ret (first s)) (rest s))
               (seq ret)))))



(def
 #^{:private true}
 sigs
 (fn [fdecl]
   (if (seq? (first fdecl))
     (loop [ret [] fdecl fdecl]
       (if fdecl
         (recur (conj ret (first (first fdecl))) (rest fdecl))
         (seq ret)))
     (list (first fdecl)))))

(def 

 #^{:doc "Same as (def name (fn [params* ] exprs*)) with any doc-string or attrs added
    to the var metadata"
    :arglists '([name doc-string? attr-map? [params*] body]
		  [name doc-string? attr-map? ([params*] body)+ attr-map?])}
 defn (fn defn [name & fdecl]
        (let [
	      m (if (string? (first fdecl))
                  {:doc (first fdecl)}
                  {})
              fdecl (if (string? (first fdecl))
                      (rest fdecl)
                      fdecl)
              m (if (map? (first fdecl))
                  (conj m (first fdecl))
                  m)
              fdecl (if (map? (first fdecl))
                      (rest fdecl)
                      fdecl)
              fdecl (if (vector? (first fdecl))
                      (list fdecl)
                      fdecl)
              m (if (map? (last fdecl))
                  (conj m (last fdecl))
                  m)
              fdecl (if (map? (last fdecl))
                      (butlast fdecl)
                      fdecl)
              m (conj {:arglists (list 'quote (sigs fdecl))} m)
	      ]
          `(def ~(with-meta name (conj (if (meta name) (meta name) {}) m)) (fn ~@fdecl)))))


(. (var defn) (setMacro))



(defn print 
  "Trace an object to *runtime*'s default output."
  [obj] (. *runtime* (traceOut (. com.las3r.runtime.RT (printToString obj)))))



(defn cast
  "Throws an Error if x is not a c, else returns x."
  [c x] (. com.las3r.runtime.RT (cast c x)))


(defn macroexpand-1
  "If form represents a macro form, returns its expansion,
  else returns form."
  [form]
  (. (. *runtime* compiler) (macroexpand1 form)))



(defn macroexpand
  "Repeatedly calls macroexpand-1 on form until it no longer
  represents a macro form, then returns it.  Note neither
  macroexpand-1 nor macroexpand expand macros in subforms."
  [form]
  (let [ex (macroexpand-1 form)]
    (if (identical? ex form)
      form
      (macroexpand ex))))

(defn vector
  "Creates a new vector containing the args."
  [& args]
  (. com.las3r.runtime.Vector (createFromSeq args)))


(defn hash-map
  "keyval => key val
  Returns a new hash map with supplied mappings."
  [& keyvals]
  (. com.las3r.runtime.Map (createFromSeq keyvals)))

(def

 #^{:doc "Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called."
    :arglists '([name doc-string? attr-map? [params*] body]
		  [name doc-string? attr-map? ([params*] body)+ attr-map?])}
 defmacro (fn [name & args]
            (list 'do
                  (cons `defn (cons name args))
                  (list '. (list 'var name) '(setMacro)))))

(. (var defmacro) (setMacro))

(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  [test & body]
  (list 'if test (cons 'do body)))

(defmacro when-not
  "Evaluates test. If logical false, evaluates body in an implicit do."
  [test & body]
  (list 'if test nil (cons 'do body)))

(defn nil?
  "Returns true if x is nil, false otherwise."
  {:tag Boolean}
  [x] (identical? x nil))

(defn false?
  "Returns true if x is the value false, false otherwise."
  {:tag Boolean}
  [x] (identical? x false))

(defn true?
  "Returns true if x is the value true, false otherwise."
  {:tag Boolean}
  [x] (identical? x true))

(defn not
  "Returns true if x is logical false, false otherwise."
  {:tag Boolean}
  [x] (if x false true))


(defn str
  "With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args."
  {:tag String}
  ([] "")
  ([x]
     (if (nil? x) "" (cast String x)))
  ([x & ys]
     (loop [sb (str x) 
	    more ys]
       (if more
	 (recur (. sb  (concat (str (first more)))) (rest more))
	 (str sb)))))


(defn symbol
  "Returns a Symbol with the given namespace and name."
  ([name] (. com.las3r.runtime.Symbol (intern1 *runtime* name)))
  ([ns name] (. com.las3r.runtime.Symbol (intern2 *runtime* ns name))))


(defn keyword
  "Returns a Keyword with the given namespace and name.  Do not use :
  in the keyword strings, it will be added automatically."
  ([name] (. com.las3r.runtime.Keyword (intern2 *runtime* nil name)))
  ([ns name] (. com.las3r.runtime.Keyword (intern2 *runtime* ns name))))


(defn gensym
  "Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is 'G'."
  ([] (gensym "G__"))
  ([prefix-string] (. com.las3r.runtime.Symbol (intern1 *runtime* (str prefix-string (str (. *runtime* (nextID))))))))

(defmacro cond
  "Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil."
  [& clauses]
  (when clauses
    (list 'if (first clauses)
	  (second clauses)
	  (cons 'cond (rest (rest clauses))))))

(defn spread
  {:private true}
  [arglist]
  (cond
   (nil? arglist) nil
   (nil? (rest arglist)) (seq (first arglist))
   :else (cons (first arglist) (spread (rest arglist)))))

(defn apply
  "Applies fn f to the argument list formed by prepending args to argseq."
  {:arglists '([f args* argseq])}
  [f & args]
  (apply* f (spread args)))

(defn list*
  "Creates a new list containing the item prepended to more."
  [item & more]
  (spread (cons item more)))



;;;;;;;;;;;;;;;;at this point all the support for syntax-quote exists;;;;;;;;;;;;;;;;;;;;;;

(defn =
  "Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers in a type-independent manner.  Clojure's immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison."
  {:tag Boolean} 
  ([x] true)
  ([x y] (. com.las3r.util.Util (equal x y)))
  ([x y & more]
     (if (= x y)
       (if (rest more)
	 (recur y (first more) (rest more))
	 (= y (first more)))
       false)))

(defn not=
  "Same as (not (= obj1 obj2))"
  {:tag Boolean}
  ([x] false)
  ([x y] (not (= x y)))
  ([x y & more]
     (not (apply = x y more))))


(defn compare
  "Comparator. Returns 0 if x equals y, -1 if x is logically 'less
  than' y, else 1. Same as Java x.compareTo(y) except it also works
  for nil, and compares numbers in a type-independent manner. x must
  implement Comparable"
  {:tag Number
   :inline (fn [x y] `(. com.las3r.util.Util compare ~x ~y))} 
  [x y] (. com.las3r.util.Util (compare x y)))

(defmacro and
  "Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true."
  ([] true)
  ([x] x)
  ([x & rest]
     `(let [and# ~x]
	(if and# (and ~@rest) and#))))

(defmacro or
  "Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil."
  ([] nil)
  ([x] x)
  ([x & rest]
     `(let [or# ~x]
	(if or# or# (or ~@rest)))))



;;;;;;;;;;;;;;;;;;; sequence fns  ;;;;;;;;;;;;;;;;;;;;;;;

(defn reduce
  "f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called."
  ([f coll]
     (let [s (seq coll)]
       (if s
	 (reduce f (first s) (rest s))
	 (f))))
  ([f val coll]
     (let [s (seq coll)]
       (if (instance? com.las3r.runtime.IReduce s)
         (. #^com.las3r.runtime.IReduce s (reduce f val))
         ((fn [f val s]
            (if s
              (recur f (f val (first s)) (rest s))
              val))
          f val s)))))

(defn reverse
  "Returns a seq of the items in coll in reverse order. Not lazy."
  [coll]
  (reduce conj nil coll))


;;math stuff
(defn +
  "Returns the sum of nums. (+) returns 0."
  ([] 0)
  ([x] (cast Number x))
  ([x y] (. com.las3r.runtime.Numbers (add x y)))
  ([x y & more]
     (reduce + (+ x y) more)))

(defn *
  "Returns the product of nums. (*) returns 1."
  ([] 1)
  ([x] (cast Number x))
  ([x y] (. com.las3r.runtime.Numbers (multiply x y)))
  ([x y & more]
     (reduce * (* x y) more)))

(defn /
  "If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators."
  ([x] (/ 1 x))
  ([x y] (. com.las3r.runtime.Numbers (divide x y)))
  ([x y & more]
     (reduce / (/ x y) more)))

(defn -
  "If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result."
  ([x] (. com.las3r.runtime.Numbers (minus x)))
  ([x y] (. com.las3r.runtime.Numbers (minus x y)))
  ([x y & more]
     (reduce - (- x y) more)))

(defn <
  "Returns non-nil if nums are in monotonically increasing order,
  otherwise false."
  ([x] true)
  ([x y] (. com.las3r.runtime.Numbers (lt x y)))
  ([x y & more]
     (if (< x y)
       (if (rest more)
	 (recur y (first more) (rest more))
	 (< y (first more)))
       false)))

(defn <=
  "Returns non-nil if nums are in monotonically non-decreasing order,
  otherwise false."
  ([x] true)
  ([x y] (. com.las3r.runtime.Numbers (lte x y)))
  ([x y & more]
     (if (<= x y)
       (if (rest more)
	 (recur y (first more) (rest more))
	 (<= y (first more)))
       false)))

(defn >
  "Returns non-nil if nums are in monotonically decreasing order,
  otherwise false."
  ([x] true)
  ([x y] (. com.las3r.runtime.Numbers (gt x y)))
  ([x y & more]
     (if (> x y)
       (if (rest more)
	 (recur y (first more) (rest more))
	 (> y (first more)))
       false)))

(defn >=
  "Returns non-nil if nums are in monotonically non-increasing order,
  otherwise false."
  ([x] true)
  ([x y] (. com.las3r.runtime.Numbers (gte x y)))
  ([x y & more]
     (if (>= x y)
       (if (rest more)
	 (recur y (first more) (rest more))
	 (>= y (first more)))
       false)))

(defn ==
  "Returns non-nil if nums all have the same value, otherwise false"
  ([x] true)
  ([x y] (. com.las3r.runtime.Numbers (equiv x y)))
  ([x y & more]
     (if (== x y)
       (if (rest more)
	 (recur y (first more) (rest more))
	 (== y (first more)))
       false)))

(defn max
  "Returns the greatest of the nums."
  ([x] x)
  ([x y] (if (> x y) x y))
  ([x y & more]
     (reduce max (max x y) more)))

(defn min
  "Returns the least of the nums."
  ([x] x)
  ([x y] (if (< x y) x y))
  ([x y & more]
     (reduce min (min x y) more)))

(defn inc
  "Returns a number one greater than num."
  [x] (. com.las3r.runtime.Numbers (inc x)))

(defn dec
  "Returns a number one less than num."
  [x] (. com.las3r.runtime.Numbers (dec x)))



